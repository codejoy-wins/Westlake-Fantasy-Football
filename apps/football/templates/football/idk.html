log base 10 of n is 10^n = log(n). n being the input size.


log 10000 = 4 

10^4 = 

log(n) =  x

log b10 (n) = x

100 === n  and 2 === y

<!-- log b10 (100) = 2

10^2 = 100

logb10 (x) = y

logb10 (100) = 2 -->

logb10 (n) =  y    ===  10^y = n\

log(n) = y   ===  10^y = n

log(5) = x   === 10^x = 5




If 10^4 = 10000 then log(10000) =4

Log unspecified has an implied base 10.

If 10^4 = 10000 then log base 10 of 10000 = 4



So if exponents are asking, "if you multiply yourself by yourself this many times what will you get?", then logs are asking, " How many times did you multiply the base of this log by to get this number?"



If 2^3 = 8 then log base 2 of 8 = 3

if you want it in base ten you can use the change of base formula:

log base x of y = (log base 10 of y) / (log base 10 of x)

so log base 2 of 8 = (log base 10 of 8) / (log base 10 of 2)

aka (log(8)) / (log(2)) = 3



so if I asked you what log base 4 of 16 was how would you rephrase it?How many times did you multiply 4 by itself to get 16?  2 times

So log base 4 of 16 = 2



Well, really you multiplied it by itself once.  So really logs are asking, " What is the exponent of this base that would give me this number?"So log base 3 of 81 = "What exponent of this base equals this number?"  or more specifically, "What exponent of 3 equals 81?"  And the answer is... well, 3^2 = 9 and 9^2 = 81 .  so (3*3)   *  (3*3) has 4 3's so I'm gonna conclude 3^4 = 81, which means that log base 3 of 81 = 4.  Log's are asking for the exponent.  This is useful for algebra problems where the variable is in the exponent.  Like algorithm notation.

I have been studying Algebra 2 and Big O (Big Omicron) notation at the same time.  They are connected.  A binary search tree's efficiency and scalability are measured as 0(log n) or something like that because a binary search of 8 numbers can take at most 3 guesses?  Ya after the 3rd guess it has narrowed it down to just 2 numbers at most of the original 8 and received a response if it is right or not.  Then, before the 4th guess, it can know with 100% certainty what the number is.  

Think of a number between 1 and 8.  Got it?  Okay... I choose 5.  Higher or lower?  Lets say you say it is higher, then I eliminate 1 through 5 as options and have 6,7,8 and choose 7, lets say you say lower, now I'm down to 6, and I guess it right.  if it was lower then 5 I eliminate 6,7,8 and have 1,2,3,4,5 and choose 3, if it's lower or higher then 3 that leaves me with 2 options for my 3rd guess, then you say yes or no, and I don't have to guess a 4th time.  I know it after 3 guesses with feedback.  2^3 = 8 and log base 2 of 8 = 3.   log base 10 of n is 10^n = log(n).   n being the input size.  So the idea is that, if you're playing 21 questions.  You should be able to tell them they can pick any number between 1 and 2^21 and still figure it out, rather than an inefficient algorithm where you can only ask them to pick a number between 1 and 21.  

2^5 = 32.  so after 5 questions I know your number if it's between 1 and 21.  Even in the worst case scenario.  Whereas, in the worst case scenario of an inefficient algorithm, It would take me 21 questions to get to your number between 1-21, if it was 21.  This is tricky though because the array has to be sorted, and you have have to tell me if it's higher or lower.  But without getting bogged down by the details, the essential point is that I can save asking 16 extra questions just by using a better approach.  

so the big o notation of asking, "Is it 1? Is it 2? ..."  is big 0 (n) which is inferior to 

big 0(log n) because 10000>log(10000) because log(10000) = 4 so 10000>4 and less is more in computer science so 4 is better than 10000.  